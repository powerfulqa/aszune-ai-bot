name: Aszune AI Bot CI/CD

# Optimized CI workflow with parallel test sharding and separate coverage
# - Tests run in 3 parallel shards for faster execution (NO coverage = speed)
# - Coverage run separately as FULL suite (no sharding = accuracy)
# - Quality and security checks run in parallel with tests
# - QLTY analysis runs to trigger maintainability checks

on:
  push:
    branches:
      - main
      - feature/*
  pull_request:
    branches:
      - main

jobs:
  # QLTY code analysis (triggers maintainability checks)
  qlty:
    name: QLTY Analysis
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Full history for accurate analysis

      - name: Install QLTY CLI
        uses: qltysh/qlty-action/install@v2

      - name: Run QLTY check
        run: qlty check --all --no-progress
        continue-on-error: true # Don't fail CI on code smells

  # Quality and security checks (fast, runs in parallel with tests)
  quality:
    name: Quality & Security
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.17.0'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run ESLint
        run: npx eslint src/ --max-warnings=0

      - name: Security audit
        run: npm audit --audit-level=high --production
        continue-on-error: true

  # Parallel test shards (3x faster than sequential) - NO COVERAGE for speed
  test:
    name: Test (Shard ${{ matrix.shard }}/3)
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      matrix:
        shard: [1, 2, 3]
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.17.0'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run tests (no coverage - speed optimized)
        run: npm test -- --shard=${{ matrix.shard }}/3 --no-coverage --maxWorkers=2 --colors
        env:
          CI: true
          NODE_ENV: test
          FORCE_COLOR: '1'

  # Full coverage run (main branch only, no sharding for accurate coverage)
  coverage:
    name: Coverage
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'
    permissions:
      contents: read
      id-token: write # Required for QLTY OIDC authentication
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22.17.0'
          cache: 'npm'

      - name: Install dependencies
        run: npm ci

      - name: Run full test suite with coverage
        run: npm test -- --coverage --maxWorkers=2 --colors
        env:
          CI: true
          NODE_ENV: test
          FORCE_COLOR: '1'

      - name: Validate coverage thresholds
        run: |
          echo "Validating coverage thresholds..."
          node -e "
            const fs = require('fs');
            const coverageSummary = JSON.parse(fs.readFileSync('coverage/coverage-summary.json', 'utf8'));
            const { statements, branches, functions, lines } = coverageSummary.total;
            
            console.log('Coverage Summary:');
            console.log(\`  Statements: \${statements.pct}%\`);
            console.log(\`  Branches:   \${branches.pct}%\`);
            console.log(\`  Functions:  \${functions.pct}%\`);
            console.log(\`  Lines:      \${lines.pct}%\`);
            
            const threshold = 70;
            const failures = [];
            
            if (statements.pct < threshold) failures.push(\`Statements: \${statements.pct}% < \${threshold}%\`);
            if (branches.pct < threshold) failures.push(\`Branches: \${branches.pct}% < \${threshold}%\`);
            if (functions.pct < threshold) failures.push(\`Functions: \${functions.pct}% < \${threshold}%\`);
            if (lines.pct < threshold) failures.push(\`Lines: \${lines.pct}% < \${threshold}%\`);
            
            if (failures.length > 0) {
              console.error('\\n❌ Coverage thresholds not met:');
              failures.forEach(f => console.error(\`  - \${f}\`));
              process.exit(1);
            }
            
            console.log('\\n✅ All coverage thresholds met!');
          "

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        continue-on-error: true
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: coverage/
          fail_ci_if_error: false

      - name: Upload coverage to QLTY
        uses: qltysh/qlty-action/coverage@v2
        continue-on-error: true
        with:
          oidc: true
          files: coverage/lcov.info

  # Final status check (ensures all jobs pass)
  ci-status:
    name: CI Status
    needs: [quality, test, coverage]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check CI status
        run: |
          if [[ "${{ needs.quality.result }}" == "failure" || "${{ needs.test.result }}" == "failure" ]]; then
            echo "❌ CI failed"
            exit 1
          fi
          if [[ "${{ github.ref }}" == "refs/heads/main" && "${{ needs.coverage.result }}" == "failure" ]]; then
            echo "❌ Coverage check failed"
            exit 1
          fi
          echo "✅ CI passed"
